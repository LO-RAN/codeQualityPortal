/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Uniface.jj */
/*@egen*//* Copyright (c) 2010, Compuware Corporation.
 * All rights reserved.
 *
 * Author : Laurent IZAC (laurent.izac@compuware.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Compuware Corporation, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  FORCE_LA_CHECK = true;
//	USER_CHAR_STREAM = true;
//	NODE_USES_PARSER=true;
  JAVA_UNICODE_ESCAPE = true; 	  
	IGNORE_CASE = true; 
	STATIC = false; 
  ERROR_REPORTING = true; 	
  JDK_VERSION = "1.5";
//	MULTI=true;
//	VISITOR=true;
}

PARSER_BEGIN(UnifaceParser)

/*
Beware : continuation markers (aka "%\") should be removed before parsing
         as they will not be handled by this grammar.
         In the context of Proc code compiling,
         this special construct is handled by some pre-processing,
         before actual compilation occurs.
*/

package com.compuware.uniface.netbeans.jccparser;
import java.util.ArrayList;
import java.util.List;

/** A Uniface 9.4.01 Grammar. */
public class UnifaceParser/*@bgen(jjtree)*/implements UnifaceParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTUnifaceParserState jjtree = new JJTUnifaceParserState();

/*@egen*/

    public List<ParseException> syntaxErrors = new ArrayList<ParseException> ();

   void recover (ParseException ex, int recoveryPoint) {
      syntaxErrors.add (ex);
      Token t;
      do {
          t = getNextToken ();
      } while (t.kind != recoveryPoint);
   }

  /** Main entry point. */

  public static void main(String args[]) {
    UnifaceParser parser;
    if (args.length == 0) {
      System.out.println("Uniface Parser Version 0.1:  Reading from standard input . . .");
      parser = new UnifaceParser(System.in);
    } else if (args.length == 1) {
      System.out.println("Uniface Parser Version 0.1:  Reading from file " + args[0] + " . . .");
      try {
        parser = new UnifaceParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Uniface Parser Version 0.1:  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Uniface Parser Version 0.1:  Usage is one of:");
      System.out.println("         java UnifaceParser < inputfile");
      System.out.println("OR");
      System.out.println("         java UnifaceParser inputfile");
      return;
    }
    try {
      parser.CompilationUnit();
      System.out.println("Uniface Parser Version 0.1:  Uniface program parsed successfully.");
    } catch (ParseException e) {
      System.out.println(e.getMessage());
      System.out.println("Uniface Parser Version 0.1:  Encountered errors during parse.");
    }
  }
/*
  public static void main(String args[]) {
    UnifaceParser parser;
    if (args.length == 0) {
          System.out.println("Reading from standard input...");
          parser = new UnifaceParser(System.in);
    } else if (args.length == 1) {
      System.out.println("Reading from file " + args[0] + " . . .");
      try {
        parser = new UnifaceParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Usage is one of:");
      System.out.println("         java UnifaceParser < inputfile");
      System.out.println("OR");
      System.out.println("         java UnifaceParser inputfile");
      return;
    }
    try {
      SimpleNode node = parser.Start();
      node.dump("");
      System.out.println("Uniface program parsed successfully.");
    } catch (Exception e) {
      System.out.println("Encountered errors during parse.");
      //System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
*/  
}

PARSER_END(UnifaceParser)

SKIP : /* WHITE SPACES */
{
  " "
| "\t"
}

TOKEN :
{
  < BR: (["\n","\r"])+ >
| < COMMA : "," >
| < COLON : ":" >
| < SEMICOLON : ";" >
| < DOLLAR : "$" >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < AT: "@" >
| < UNDERSCORE: "_" >
| < DOT: "." >
}


/* OPERATORS */
TOKEN :/* arithmetic operators */
{
  < MULTIPLY: "*" >
| < DIVIDE: "/" > 
| < MODULO: "%" >
| < PLUS: "+" >
| < MINUS: "-" >
| < COMPUTE: "compute" >
}

TOKEN :/* relational operators */
{
  < EQUAL: "=" >
| < LT: "<" >
| < GT: ">" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
}

TOKEN :/* assignment operators */
{
  < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < REMASSIGN: "%=" >
}

TOKEN :/* logical operators */
{
  < NOT: "!" >
| < OR: "|" >
| < AND: "&" >
}

TOKEN :
{
  <COMMENT: <SEMICOLON> (~["\n", "\r"])* >
} 

TOKEN : /* literals */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
| < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| < #OCTAL_LITERAL: "0" (["0"-"7"])* >
| < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
| < #DECIMAL_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
| < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
| < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
| < SYNTAX_STRING_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
| < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}


TOKEN : /* parameter and variable blocks */
{
  < PARAMS: "params" >
| < ENDPARAMS: "endparams" >
| < VARIABLES: "variables" >
| < ENDVARIABLES: "endvariables" >
}

TOKEN : 
{
  < IF: "if" >
| < ELSEIF: "elseif" >
| < ELSE: "else" >
| < ENDIF: "endif" >
| < WHILE: "while" >
| < ENDWHILE: "endwhile" >
| < REPEAT: "repeat" >
| < UNTIL: "until" >
| < SELECTCASE: "selectcase" >
| < CASE: "case" >
| < ELSECASE: "elsecase" >
| < ENDSELECTCASE: "endselectcase" >
}

TOKEN : /* data types */
{
  < BOOLEAN: "boolean" >
| < DATE: "date" >
| < DATETIME: "datetime" >
| < FLOAT: "float" >
| < HANDLE: "handle" >
| < IMAGE: "image" >
| < LINEARDATE: "lineardate" >
| < LINEARDATETIME: "lineardatetime" >
| < LINEARTIME: "lineartime" >
| < NUMERIC: "numeric" >
| < RAW: "raw" >
| < STRING: "string" >
| < TIME: "time" >
| < ANY: "any" >
| < ENTITY: "entity" >
| < OCCURRENCE: "occurrence" >
| < XMLSTREAM: "xmlstream" >
}

TOKEN : 
{
  < FUNCTION : <DOLLAR> <IDENTIFIER> >
}


TOKEN : /* statements : Components and Component Instances */
{
  < DELETEINSTANCE : "deleteinstance" >
| < NEWINSTANCE: "newinstance" >
| < SETFORMFOCUS: "setformfocus" >
}

TOKEN : /* statements : Data Conversion and System Information */
{
  < ENTITYCOPY : "entitycopy" >
}

TOKEN : /* statements : Data Manipulation */
{
  < ADDMONTHS : "addmonths" >      
| < COMPARE : "compare" >        
| < DISPLAYLENGTH : "displaylength" >  
| < LENGTH : "length" >         
| < LOWERCASE : "lowercase" >      
| < RESET : "reset" >          
| < SCAN : "scan" >           
| < SET : "set" >            
| < STRIPATTRIBUTES : "stripattributes" >
| < UPPERCASE : "uppercase" >
  }

TOKEN : /* statements : DBMS Path I/O */
{
  < CLOSE : "close" >   
| < COMMIT : "commit" > 
| < OPEN : "open" >
| < ROLLBACK : "rollback" >
| < SQL : "sql" >
}

TOKEN : /* statements : Process flow */
{
  < ACTIVATE : "activate" >   
| < APEXIT : "apexit" > 
| < APSTART : "apstart" >
| < BREAK : "break" >
| < DISPLAY : "display" >
| < DONE : "done" >
| < EDIT : "edit" >
| < EXIT : "exit" >
| < GOTO : "goto" >
| < MACRO : "macro" >
| < PERFORM : "perform" >
| < PULLDOWN : "pulldown" >
| < RETURN : "return" >
| < RUN : "run" >
| < SPAWN : "spawn" >
}





TOKEN : /* statements : Message Text and Display */
{
  < CLRMESS : "clrmess" >   
| < ASKMESS : "askmess" > 
| < MESSAGE : "message" >
| < PUTMESS : "putmess" >
}

TOKEN : /* statements : other */
{
  < DEBUG : "debug" >   
}

TOKEN : /* parameter directions */
{
  < IN: "in"  >
| < OUT: "out" >
| < INOUT: "inout" >
}

TOKEN : /* switches */
{
  < SYNC_SWITCH: "/sync"  >
| < ASYNC_SWITCH: "/async" >
| < ATTACHED_SWITCH: "/attached" >
| < PREVIOUS_SWITCH: "/previous" >
| < NEXT_SWITCH: "/next" >
| < PRINT_SWITCH: "/print" >
| < INIT_SWITCH: "/init" >
| < LIST_SWITCH: "/list" >
| < STATELESS_SWITCH: "/stateless" >
| < MENU_SWITCH: "/menu" >
| < FROM: "from" >
}

TOKEN : /* identifiers */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|<UNDERSCORE>|<DOT>)* >
| < #LETTER: ["a"-"z","A"-"Z"] >
| < DIGIT: ["0"-"9"] >
}


TOKEN :
{
  < REGISTER : <DOLLAR><DIGIT>(<DIGIT>)? >
| < GLOBALVARIABLE : <DOLLAR> <DOLLAR> <IDENTIFIER> >
| < COMPONENTVARIABLE : <DOLLAR> <IDENTIFIER> <DOLLAR> >
}


TOKEN : /* compile time constants */
{
  < CMPSTATEMANAGEDBY: "<$cmpStateManagedBy>" >
| < COMPONENTNAME: "<$componentName>" >
| < COMPONENTTYPE: "<$componentType>" >    
| < ENTNAME: "<$entName>" >          
| < FIELDNAME: "<$fieldName>" >        
| < LIBRARYNAME: "<$libraryName>" >      
| < MODELNAME: "<$modelName>" >        
| < TABLENAME: "<$tableName>" >        
| < TRIGGERABBR: "<$triggerAbbr>" >      
}

// Prevent lexer-generated errors if unexpected character.
TOKEN :
{
    < ANYTHING_ELSE: ( ~[] ) >
}

/*************************************************
 * THE UNIFACE PROC LANGUAGE GRAMMAR STARTS HERE *
 *************************************************/
  
/** Main production. */

void CompilationUnit():
{/*@bgen(jjtree) CompilationUnit */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
try {
/*@egen*/
try { 

  (LOOKAHEAD(2) CommentLine())*
  (ParameterBlock())?
  (LOOKAHEAD(2) CommentLine())*
  (VariableBlock())?
  ( Instruction() )*
  <EOF>
} catch (ParseException ex) {
        recover (ex, BR);
    }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
/**            */

void Argument() : {/*@bgen(jjtree) Argument */
  SimpleNode jjtn000 = new SimpleNode(JJTARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Argument */
  try {
/*@egen*/
  Expression() ( LOOKAHEAD(2) <COMMA> Argument() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  //Source [ Start {: Num|, End}] 
  LogicalExpression() ( <LBRACKET> LogicalExpression() (<COLON>|<COMMA>) LogicalExpression() <RBRACKET> )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CompileTimeConstant() : {/*@bgen(jjtree) CompileTimeConstant */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPILETIMECONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompileTimeConstant */
  try {
/*@egen*/
  (
    <CMPSTATEMANAGEDBY>
|   <COMPONENTNAME>    
|   <COMPONENTTYPE>    
|   <ENTNAME>          
|   <FIELDNAME>        
|   <LIBRARYNAME>      
|   <MODELNAME>        
|   <TABLENAME>        
|   <TRIGGERABBR>
)/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Constant() : {/*@bgen(jjtree) Constant */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Constant */
   try {
/*@egen*/
   (<LT> <IDENTIFIER> <GT>|CompileTimeConstant())/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/ 
}

void ExpressionList() : {/*@bgen(jjtree) ExpressionList */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionList */
  try {
/*@egen*/
  Expression() (<COMMA> Expression())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A logical Expression. */
void LogicalExpression() : {/*@bgen(jjtree) LogicalExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTLOGICALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalExpression */
  try {
/*@egen*/
  RelationalExpression() ( ( <NOT> | <AND>| <OR>) RelationalExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An relational Expression. */
void RelationalExpression() : {/*@bgen(jjtree) RelationalExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationalExpression */
  try {
/*@egen*/
  AdditiveExpression() ( ( <LT> | <GT>| <LE>| <GE> | <EQUAL>| <EQ>| <NE>) AdditiveExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Additive Expression. */
void AdditiveExpression() : {/*@bgen(jjtree) AdditiveExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AdditiveExpression */
  try {
/*@egen*/
  MultiplicativeExpression() ( ( <PLUS> | <MINUS> ) MultiplicativeExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A Multiplicative Expression. */
void MultiplicativeExpression() : {/*@bgen(jjtree) MultiplicativeExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiplicativeExpression */
  try {
/*@egen*/
  UnaryExpression() ( ( <MULTIPLY> | <DIVIDE> | <MODULO> ) UnaryExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A Unary Expression. */
void UnaryExpression() : {/*@bgen(jjtree) UnaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryExpression */
  try {
/*@egen*/
  <LPAREN> Expression() <RPAREN>
| Constant()
| Integer()
| UserDefinedFunction()
| String()
| Function()
| Register()
| GlobalVariable()
| ComponentVariable()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void UserDefinedFunction() : {/*@bgen(jjtree) UserDefinedFunction */
  SimpleNode jjtn000 = new SimpleNode(JJTUSERDEFINEDFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UserDefinedFunction */
  try {
/*@egen*/
  Identifier() ( LOOKAHEAD(2) <LPAREN> Expression() (<COMMA> Expression())? <RPAREN> )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A String. */
void String() : {/*@bgen(jjtree) String */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  <STRING_LITERAL>
| <SYNTAX_STRING_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Identifier. */
void Identifier() : {/*@bgen(jjtree) Identifier */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  <IDENTIFIER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Register() : {/*@bgen(jjtree) Register */
  SimpleNode jjtn000 = new SimpleNode(JJTREGISTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Register */
  try {
/*@egen*/
  <REGISTER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void GlobalVariable() : {/*@bgen(jjtree) GlobalVariable */
  SimpleNode jjtn000 = new SimpleNode(JJTGLOBALVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GlobalVariable */
  try {
/*@egen*/
  <GLOBALVARIABLE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ComponentVariable() : {/*@bgen(jjtree) ComponentVariable */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPONENTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ComponentVariable */
  try {
/*@egen*/
  <COMPONENTVARIABLE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IdentifierList() : {/*@bgen(jjtree) IdentifierList */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IdentifierList */
  try {
/*@egen*/
  Identifier() (<COMMA> Identifier())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Integer. */
void Integer() : {/*@bgen(jjtree) Integer */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Integer */
  try {
/*@egen*/
  <INTEGER_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A Datatype. */
void Datatype() : {/*@bgen(jjtree) Datatype */
  SimpleNode jjtn000 = new SimpleNode(JJTDATATYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Datatype */
  try {
/*@egen*/
  <BOOLEAN>
| <DATE>
| <DATETIME>
| <FLOAT>
| <HANDLE>
| <IMAGE>
| <LINEARDATE>
| <LINEARDATETIME>
| <LINEARTIME>
| <NUMERIC>
| <RAW>
| <STRING>
| <TIME>
| <ANY>
| <ENTITY>
| <OCCURRENCE>
| <XMLSTREAM>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A Direction. */
void Direction() : {/*@bgen(jjtree) Direction */
  SimpleNode jjtn000 = new SimpleNode(JJTDIRECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Direction */
  try {
/*@egen*/
  <IN>
| <OUT>
| <INOUT>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A variable definition*/
void VariableDefinition() : {/*@bgen(jjtree) VariableDefinition */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDefinition */
  try {
/*@egen*/
  Datatype() Identifier() (<COMMA> Identifier())* (Comment())? <BR>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A parameter */
void Parameter() : {/*@bgen(jjtree) Parameter */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Parameter */
  try {
/*@egen*/
  Datatype() Identifier() <COLON> Direction() (Comment())? <BR>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** A parameter block */
void ParameterBlock() : {/*@bgen(jjtree) ParameterBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAMETERBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterBlock */
   try {
/*@egen*/
   <PARAMS>  (Comment())? <BR> ( Parameter() | CommentLine() )* <ENDPARAMS>  (Comment())? <BR>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}
/** A variable block */
void VariableBlock() : {/*@bgen(jjtree) VariableBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableBlock */
   try {
/*@egen*/
   <VARIABLES>  (Comment())? <BR> ( VariableDefinition()  | CommentLine() )* <ENDVARIABLES>  (Comment())? <BR>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void Comment() : {/*@bgen(jjtree) Comment */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Comment */
  try {
/*@egen*/
  <COMMENT>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CommentLine() : {/*@bgen(jjtree) CommentLine */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMMENTLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CommentLine */
  try {
/*@egen*/
  Comment() <BR>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Instruction. */
void Instruction() : {/*@bgen(jjtree) Instruction */
  SimpleNode jjtn000 = new SimpleNode(JJTINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instruction */
 try {
/*@egen*/
 (
    LOOKAHEAD(2) ProcStatement() (Comment())? <BR>
  | IfStatement()
  | WhileStatement()
  | RepeatStatement()
  | SelectCaseStatement()
  | LabelStatement()
  | CommentLine()
 )/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}


void ProcStatement() : {/*@bgen(jjtree) ProcStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTPROCSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ProcStatement */
   try {
/*@egen*/
   Statement() 
|  Assignment()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void Indirection() : {/*@bgen(jjtree) Indirection */
  SimpleNode jjtn000 = new SimpleNode(JJTINDIRECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Indirection */
  try {
/*@egen*/
  <AT>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Compute() : {/*@bgen(jjtree) Compute */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Compute */
  try {
/*@egen*/
  <COMPUTE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
/** An assignment. */
void Assignment() : {/*@bgen(jjtree) Assignment */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
 try {
/*@egen*/
 (Compute())? (Indirection())? (
                     Identifier()
                   | Register()
                   | GlobalVariable()
                   | ComponentVariable()
                   | Function()
                  ) (<INIT_SWITCH>)? <EQUAL> (Indirection())? Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}
/** A function. */
void Function() : {/*@bgen(jjtree) Function */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Function */
 try {
/*@egen*/
 <FUNCTION> ( LOOKAHEAD(2) <LPAREN> (ExpressionList())? <RPAREN> )?/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void IfStatement() :
{/*@bgen(jjtree) IfStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
try {
/*@egen*/
<IF> <LPAREN> Expression() <RPAREN>
(
  LOOKAHEAD(3) Instruction()
| 
  (Comment())? <BR> ( Instruction() )* ( <ELSEIF> <LPAREN> Expression() <RPAREN> (Comment())? <BR> ( Instruction() )*)* ( <ELSE> (Comment())? <BR> ( Instruction() )*)? <ENDIF> (Comment())? <BR>
)/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void WhileStatement() :
{/*@bgen(jjtree) WhileStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
try {
/*@egen*/
<WHILE> <LPAREN> Expression() <RPAREN> (Comment())? <BR> ( Instruction() )* <ENDWHILE> (Comment())? <BR>/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void RepeatStatement() :
{/*@bgen(jjtree) RepeatStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTREPEATSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RepeatStatement */
try {
/*@egen*/
<REPEAT> (Comment())? <BR> ( Instruction() )* <UNTIL> <LPAREN> Expression() <RPAREN> (Comment())? <BR>/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void SelectCaseStatement() :
{/*@bgen(jjtree) SelectCaseStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSELECTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SelectCaseStatement */
try {
/*@egen*/
<SELECTCASE> Expression() (Comment())? <BR> ( Instruction() )* ( <CASE> Expression() (Comment())? <BR> ( Instruction() )*)* ( <ELSECASE> (Comment())? <BR> ( Instruction() )*)? <ENDSELECTCASE> (Comment())? <BR>/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void LabelStatement() :
{/*@bgen(jjtree) LabelStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTLABELSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabelStatement */
try {
/*@egen*/
Identifier() <COLON> (Comment())? <BR>/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

/** A Statement. */
void Statement() : {/*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
  try {
/*@egen*/
  DeleteinstanceStatement()
| NewinstanceStatement()
| SetformfocusStatement()
| EntitycopyStatement()
| AddmonthsStatement()      
| CompareStatement()        
| DisplaylengthStatement()  
| LengthStatement()         
| LowercaseStatement()      
| ResetStatement()          
| ScanStatement()           
| SetStatement()            
| StripattributesStatement()
| UppercaseStatement()
| CloseStatement()   
| CommitStatement()  
| OpenStatement()    
| RollbackStatement()
| SqlStatement()
| GotoStatement()
| ClrmessStatement()
| DebugStatement()
| ActivateStatement()
| DisplayStatement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** Statements */

void DeleteinstanceStatement() : {/*@bgen(jjtree) DeleteinstanceStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTDELETEINSTANCESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeleteinstanceStatement */
  try {
/*@egen*/
  // deleteinstance InstanceName 
  <DELETEINSTANCE> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void NewinstanceStatement() : {/*@bgen(jjtree) NewinstanceStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTNEWINSTANCESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NewinstanceStatement */
  try {
/*@egen*/
  // newinstance{/sync | /async}{ /attached} ComponentName , Handle | InstanceName {, InstProperties} 
  <NEWINSTANCE> (<SYNC_SWITCH> | <ASYNC_SWITCH>)? (<ATTACHED_SWITCH>)? Expression() <COMMA> Expression() ( <COMMA> Expression() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SetformfocusStatement() : {/*@bgen(jjtree) SetformfocusStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSETFORMFOCUSSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SetformfocusStatement */
  try {
/*@egen*/
  // setformfocus {InstanceName}
  <SETFORMFOCUS> ( LOOKAHEAD(2) Expression() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void EntitycopyStatement() : {/*@bgen(jjtree) EntitycopyStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTENTITYCOPYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EntitycopyStatement */
  try {
/*@egen*/
  // entitycopy Source , Target {, Options}
  <ENTITYCOPY> Expression() <COMMA> Expression() ( <COMMA> Expression() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AddmonthsStatement() : {/*@bgen(jjtree) AddmonthsStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTADDMONTHSSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AddmonthsStatement */
  try {
/*@egen*/
  // addmonths Months , Date{, ReferenceDate} 
  <ADDMONTHS> Expression() <COMMA> Expression() ( <COMMA> Expression() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CompareStatement() : {/*@bgen(jjtree) CompareStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPARESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompareStatement */
  try {
/*@egen*/
  // compare{/previous | /next} (FieldList) {from Entity}  
  <COMPARE> (<PREVIOUS_SWITCH> | <NEXT_SWITCH>)? (Identifier()|<LPAREN> IdentifierList()<RPAREN>) (<FROM> Expression())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DisplaylengthStatement() : {/*@bgen(jjtree) DisplaylengthStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTDISPLAYLENGTHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DisplaylengthStatement */
  try {
/*@egen*/
  // displaylength String 
  <DISPLAYLENGTH> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void LengthStatement() : {/*@bgen(jjtree) LengthStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTLENGTHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LengthStatement */
  try {
/*@egen*/
  // length String 
  <LENGTH> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void LowercaseStatement() : {/*@bgen(jjtree) LowercaseStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTLOWERCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LowercaseStatement */
  try {
/*@egen*/
  // lowercase Source , Target 
  <LOWERCASE> Expression()<COMMA> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ResetStatement() : {/*@bgen(jjtree) ResetStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTRESETSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ResetStatement */
  try {
/*@egen*/
  // reset LitProcFunctionName  
  <RESET> Function()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ScanStatement() : {/*@bgen(jjtree) ScanStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSCANSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ScanStatement */
  try {
/*@egen*/
  // scan String , Profile   
  <SCAN> Expression() <COMMA> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void SetStatement() : {/*@bgen(jjtree) SetStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSETSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SetStatement */
  try {
/*@egen*/
  // set LitProcFunctionName 
  <SET> Function()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void StripattributesStatement() : {/*@bgen(jjtree) StripattributesStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRIPATTRIBUTESSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StripattributesStatement */
  try {
/*@egen*/
  // stripattributes Source, Target  
  <STRIPATTRIBUTES> Expression() <COMMA> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void UppercaseStatement() : {/*@bgen(jjtree) UppercaseStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTUPPERCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UppercaseStatement */
  try {
/*@egen*/
  // uppercase Source , Target   
  <UPPERCASE> Expression()<COMMA> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CloseStatement() : {/*@bgen(jjtree) CloseStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTCLOSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CloseStatement */
  try {
/*@egen*/
  // close {" PathString "}   
  <CLOSE> ( LOOKAHEAD(2) Expression() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CommitStatement() : {/*@bgen(jjtree) CommitStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMMITSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CommitStatement */
  try {
/*@egen*/
  // commit {" PathString "}    
  <COMMIT> ( LOOKAHEAD(2) Expression() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void OpenStatement() : {/*@bgen(jjtree) OpenStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTOPENSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OpenStatement */
  try {
/*@egen*/
  // open LogonParameters , " PathString " {/net}    
  <OPEN> ( LOOKAHEAD(2) Expression() <COMMA > )? Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RollbackStatement() : {/*@bgen(jjtree) RollbackStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTROLLBACKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RollbackStatement */
  try {
/*@egen*/
  // rollback {" PathString "}     
  <ROLLBACK> ( LOOKAHEAD(2) Expression() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SqlStatement() : {/*@bgen(jjtree) SqlStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTSQLSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SqlStatement */
  try {
/*@egen*/
  // sql{/print} DMLStatement , " PathString "      
  <SQL> (<PRINT_SWITCH>)? Expression()<COMMA> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ActivateStatement() : {/*@bgen(jjtree) ActivateStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTACTIVATESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ActivateStatement */
  try {
/*@egen*/
  // activate {/list | /sync | /async | /stateless} InstName {. LitOperationName ( {ArgumentList}) }   
  <ACTIVATE> (<LIST_SWITCH> | <SYNC_SWITCH> | <ASYNC_SWITCH> | <STATELESS_SWITCH>)? Expression()  (<DOT> Identifier() <LPAREN> (ExpressionList())? <RPAREN>)?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DisplayStatement() : {/*@bgen(jjtree) DisplayStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTDISPLAYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DisplayStatement */
  try {
/*@egen*/
  // display{/menu}{LitFieldName} 
  <DISPLAY> (<MENU_SWITCH>)? Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void GotoStatement() : {/*@bgen(jjtree) GotoStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTGOTOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GotoStatement */
  try {
/*@egen*/
  // goto Label    
  <GOTO> Identifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void ClrmessStatement() : {/*@bgen(jjtree) ClrmessStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTCLRMESSSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClrmessStatement */
  try {
/*@egen*/
  // clrmess    
  <CLRMESS>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DebugStatement() : {/*@bgen(jjtree) DebugStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTDEBUGSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DebugStatement */
  try {
/*@egen*/
  // debug    
  <DEBUG>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}







